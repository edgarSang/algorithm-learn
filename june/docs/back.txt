01/29 1강
    1.시간복잡도
    -O(1) : 단순 계산 
    -O(lgN) : N개를 절반으로 계속해서 나눔
    -O(N) : 1중 for문
    -O(N lg N)
    -O(N^2) : 2중퍼문
    -O(N^3) : 3중퍼문
    -O(2^n) : 크기가 N인 집합의 부분집합 
        ex) 1 2 3 ..... N 개일때 각각 O,X를 선택해야하는경우
    -O(N!) :크기가 n인 순열
        ex) 1 2 3 ..... N 일때 1,2,3 1,3,2 순서가 중요할때

    2.계산법
    -Big O 에서 상수는 버린다.
    -O(N^2) = O(N^2)
    -O(5) = O(1)
    -두가지항 이있을때, 변수가 같으면 큰 것만 빼고 다 버린다.
    -O(N^2 + N) = O(N^2)
    -두가지 항이 있는데 변수가 다르면 놔둔다
    ex)O(N^2 + M)  N이 10 M은 1000일때

01/30 2강
    1. 스택
    -배열로 스택 구현 
    push : stack[size] = v; size += 1;
    pop : stack[size-1] = 0; size -= 1;


02/08 4강
4강 DP:다이나믹이란 그냥 큰문제를 작개 쪼개서 푸는것, dynamic은 아무의미가 없다.
    - Overlapping Subproblem => 문제가 겹쳐야 한다.
        ex) 피보나치수열 F0 = 0 , F1 = 1 , Fn = Fn-1 + Fn-2 (단 n>=2 일때),
        문제 : N번째 피보나치 수를 구하는 문제.
        작은문제 : N-1 번째, N-2번째를 구하는문제
        
        문제 : N-1번째 피보나치 수를 구하는 문제.
        작은문제 : N-2 번째, N-3번째를 구하는문제
        
        문제 : N-2번째 피보나치 수를 구하는 문제.
        작은문제 : N-3 번째, N-4번째를 구하는문제
        1.작은문제들이 겹치고있다. (다이나믹 프로그램의 특징1)
        2.작은문제가 큰 문제가 된다. 작은문제를 큰문제로 풀수있다.

    - Optimal Substructure
    문제의 정답을 작은문제의 정답에서 구할 수 있다.
    ex)서울에서 부산을 가장 빠른길이 대전과 대구를 순서대로 거쳐야한다면
    -대전에서 부산을 가장 빠른길은 대구를 거쳐야한다.

    =>Dynamic 프로그래밍
     - 다이나믹 프로그래밍에서 각 문제는 한번만 풀어야한다.
     - Optimal Substructure를 만족하기 때문에 같은문제는 구할때마다 정답이 같다.
     - 따라서 정답을 한번 구했으면, 정답을 어딘가에 메모해놓는다
     - 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는것으로 할 수 있다.
     - 메모를 한다고 해서 영어로 memoization 이라고한다.


    ㅁTOP-DOWN
        1.문제를 작은 문제로 나눈다.
        2.작은 문제를 푼다.
        3.작은문제를 풀었으니, 이제 문제를 푼다.

        ex) 
        1.문제를 풀어야 한다 
            -fibonacci(n)
        2.문제를 작은문제로 나눈다.
            -fibonacci(n-1) 과 fibonacci(n-2)로 문제를 나눈다.
        3.작은문제를 푼다.
            -fibonacci(n-1) 과 fibonacci(n-2)를 호출해서 문제를푼다.
        4.작은 문제를 풀었으니 이제 문제를 푼다.
            -fibonacci(n-1)의 값과 fibonacci(n-2)의 값을 더해서문제를푼다
        
        탑다운은 재귀호출을 이용해서 쉽게 문제를 풀수있다.
        탑다운은 시간복잡도 구하는게 조금어렵다. 일단 함수의 시간복잡도를 구한다.
    ㅁBOTTOM-UP
        1.문제를 크기가 작은문제부터 차례대로 푼다(하나도 빠짐없이)
        2.문제의 크기를 조금씩 크게 만들면서 문제를 점점푼다.
        3.작은 문제를 풀면서 왔기때문에, 큰문제는 항상 풀 수 있다.
        4.그러다보면 언젠간 풀어야하는 문제를 풀수있다.

        EX) 주로 for문을 사용해서 푼다.
        int d[100];
        int fibonacci(int n) {
            d[0] = 0;
            d[1] = 1;

            for (int i=2; i<=n; i++) {
                d[i] = d[i-1] + d[i-2];
            }
            
            return d[n];
        }

    다이나믹 프로그래밍이어렵다면 하나만 잡아서 연습하세여.

    ㅁ문제풀이 전략.
        memo[i] = i번째 피보나치수 
        d,dp[i] =   i번째 피보나치수 = d[i-1] + d[i-2]
        1.?가 뭔지 구하세요
        2.식을 만들어보세요 
        3.이 이후에는 테이블을 채워가세요
        4.down up 은 문제를 많이 풀면서 감을잡는 게 중요하니 많이풀어보세요

    ㅁ1463 문제. 
        1.이게 다이나믹 문제 케이스 인지 확인해본다.
        2.D[n] 이 어떤값이 저장되는지 알아본다. 대부분 문제에서 하라고 하는 내용이 D[n] 이들어간다.
            - D[N] => N => 1로 만드는 최소값
            N에 어떤연산을 할수있나?
            2.1.N을 3으로 나눈다.
                2.1.1.문제는 2파트로 나눈다. N을 N/3으로 만드는과정, N/3을 1로만드는 과정은 D[N/3]이다. 곧 D[N/3] + 1 이다.
                2.1.2.2로나누경우 D[N/2] + 1
                2.1.3 -1로 빼는경우 D[N-1] + 1
                D[N] = min(D[N/3], D[N/2], D[N-1])
    
    ㅁ11726 타일 문제.
        1.D[n] 에는 2xN 타일을 채우는 방법의 수가 들어가게 됩니다.
            (1)길이가 n일때 세로로 놓는방법.
                넓이는 2x(n-1)
            (2)길이가 n일때 가로로 놓는방법.
                넓이는 2x(n-2)

            - 위 두가지 경우의 수를 더해주면 됩니다.
            D[n] = D[n-1] + D[n-2]

            - 그러면 제일 작은문제의 크기는 몇일까요?
            1 <= N <= 1000, 제일 작은문제의 크기는 2x1 2x0 둘다 해도됩니다.

            - 2x0을 채우는 방법은 1개가 됩니다 왜일까요?
    dp에서 중요 key point는 d[N] 을 어떻게 채울것인지랑, 채운뒤에는 무조건 return d[N]을 해줘야함

    ㅁ9095 문제
        1.n 올 수 있는수 1,2,3합
            1.1) 1이올경우 나머지의 합: n-1 
            1.2) 2가 올경우 나머지의 합: n-2
            1.3) 3이 올경우 나머지의 합: n-3

    결론: 마지막에 올수있는수가 N번째 수에 뭐가 올 수 있는지?
--------------참고-------------
문제 링크 : https://www.acmicpc.net/problem/문제번호
A+B : 1000 2558 10950 ~ 3 11021 11022
1일차 연문: 2742 2739 1924 8393 10818 2438~2446, 2522, 10991, 10992
2강 스택:9012,1406
3강 큐: 10845, 1158 , 문자열: 10820, 2743
4강: 1463, 11726, 11727,9095, 11052
5강 Dp2: 2193, 10844, 9465, 2156 