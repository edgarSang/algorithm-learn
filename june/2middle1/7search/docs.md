비트연산
-------------
A B ~A A&B A|B A^B
0 0  1  0   0   0
1 0  0  0   1   1
0 1  1  0   1   1
1 1  0  0   1   0

1. 두수를 비트연산 하면 맨뒤부터 하나씩
2. A = 27 B = b3
A =  0 0 1 1 0 1 1
B = ^1 0 1 0 0 1 1 
     1 0 0 1 0 0 0 = 73

Not 연산
-------------------
- 자료형에 따라 결과가 달라진다
- A = 83 = 1010011
- ~A = 10101100 (char) 1비트
- ~A = 1111111  1111111 1111111 10101100 (int)32비트
- unsigned, signed 에 따라서 달라진다.

Shift 연산
------------------------------
A << B (A를 왼쪽으로 B비트만큼 민다.)
- 1 << 0 = 1
- 1 << 1 = 2 
- 1 << 2 = 4
- 1 << 3 = 8
- 1 << 4 = 16
- 3 << 3 = 24
- 5 << 10 = 5120
A << B 는 A x 2^B 이다.


A >> B (오른쪽으로 민다.)
A/2^B 와 같다

- (A+B) / 2 는 (A+B) >> 1 로 축약가능
- 어떤수가 홀수인지 판별하는 N%2==1 은 if(N & 1) 로 줄여쓰기 

정수로 집합을 나타낼 수있다
------------------------
- 포함 되어있다, 안되어 있다는 O/X 
- 570 = 1 0 0 0 1 1 1 0 1 0
-       9       5 4 3   1
- = 즉 길이가 N 인 이진수

부분집합에 해당 수가 있는지 검사
------------------------------
0. {1,3,4,5,9} = 570 (밑수 2는 생략후 그냥 집합으로 표기한것임)

1. 0이 포함되어 있는지 검사
 - 570 & 2^0 = 570 & (1<<0) = 0;
2. 1이 포함되어 있는지 검사
 - 570 & 2^1 = 570 & (1<<1) = 2;
2. 2이 포함되어 있는지 검사
 - 570 & 2^2 = 570 & (1<<2) = 0; 
- 즉 어떤 집합 x에 x번째 비트만 1을 해주면 부분집합인지 알면된다.


추가하기 |
----------------
- {1,3,4,5,9} = 570

1. 1추가하기 
 - 570 | 2^1 = 570 + (1 << 1) = 570 (1000111010)

2. 2추가하기 
 - //두가지방법이 있지만 |연산을 하세요 그래야 캐리가 x
 - 570 | 2^1 = 570 + (1 << 2) = 574 (1000111110)
 

제거하기 & ~
----------------
1. 1제거하기
 - 570 & ~2^1 = 568 (1000111000)

전체집합, 공집합
---------------
(1 << N) -1 = 2^n - 1
0

비트마스크를 쓰는이유는?
------------------
 - 배열을 사용하는 것이 편리하지만
 - 집합을 배열의 인덱스로 표현 가능
 - 상태다이나믹이나 완전탐색을 할때도 재귀없이 for문 한번으로가능


-------------------
11723