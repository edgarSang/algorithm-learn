1.그래프의 표현: 그래프의 표현이라함은 그래프를 저장하는 방식
 - 정점: {1,2,3,4,5,6} = 개수
 - 간선: {(1,2), (1,5), (2,5) .... (4,6)} = O-O
 - 그래프 문제시 N, M(그래프의개수, 간선개수)
 - 뒤에 무엇과 무엇이 연결되어있는지 제시됨 1 2, 1 5, 2 3, ....

2.인접 행렬(Adjacency - matrix)
 - 정점의 개수를 V이라고 했을때
 - V x V 크기의 이차원 배열에 저장
 - A[i][j] = 1 (가는길이 있을때), 0(가는길 없을때)
 - 중요한 성질은아니지만, 양방향그래프일때 대각선을 제외하고 대칭을이름
 - 인접행렬은 자주사용하지 않는데, 이유는 공간의 낭비가 있기때문이다
 - 인접행렬로 저장하려면 V^2이 필요한데 실제 간선은 이보다 작다.

->위는 가중치가 없을때 저장하는 방법이었다.
 - 간선의 가중치가 존재할경우
    u v w
    1 2 4   = > 이럴경우 A[u][v]=4 로 저장하면된다. 
    2 4 5

3.인접 리스트:링크드 리스트를 이용해 구현 (Adjacency-list)
 - A[i] = i와 연결된 정점을 링크드 리스트로 포함하고있음
   A[1] 2 5, A[2] 1 3 4 5 
   A[3] 2 4 ......
   - 위에서 A[1]에서 2,5는 사실 정점이 아니라 간선을 나타낸다.
   -> 1-2, 1-5 라는 뜻이다.
 - 인접행렬에서 필요 공간이 V^2 이면 인접 리스트에는 모든간선이 1번씩저장됨.
   O(E) = 간선의 갯수만큼.

 - 링크드 리스트는 시간이 오래걸리기때문에, 주로 vector와 같은 걸 사용한다.
 - vector<int> a(10) 과 vector<int> a[10]은 다르다.(1차원, 2차원)
  ->vector<vcetor<int>> a[10]
 
 - 가중치가 있을경우
   A[1] (2,5) (5,2) ....
  ->vetor<pair<int,int>> 로 선언.
  결론: 공간복잡도 인접행렬:O(V^2), 인접리스트 O(E)

3.간선리스트: 인접행렬이나 인접 리스트 둘다 사용x 경우가있음(Edge-list)
 - 어떤 경우냐면 STL이나 arraylist를 사용할 수 없거나 잘모르는 경우.
 - 이럴경우는 간선리스트를 이용해 저장함
 - 저장순서.
   1.E라는 배열에 간선을 모두 저장.
    E[0] = 1 2 E[1] = 1 5 ....
   2.cnt 배열을 만들어 각 간선의 앞 정점을 기준으로 개수를센다.
   [EdgeList.jpg 참고]
    - 코드로 나타내면
      for(int i=0; i<m; i++){
          cnt[e[i][0]] += 1; 이다
      }
    - 이 다음에 cnt배열을 누적하여 누적값을 구한다.
     for(int i=1; i<=n; i++){
         cnt[i] = cnt[i-1] + cnt[i];
     }
    - 놀라운 사실은 i번정점과 연결된 간선은
      E 배열에서 E[cnt[i-1]] ~ E[cnt[i]-1] 까지이다 (EdgeList3.jpg) 참고

= 그래프를 저장하는 것은 간선을 저장하는 것이다.
 - 인접리스트, 인접행렬, 간선 리스트 많이쓰는건 인접리스트,간선리스트이다.

[그래프의 탐색] : DFS,BFS => 목적은 모든 정점을 1번씩방문
 1.깊이우선 탐색(depth first search)
  ->최대한 깊숙히 많이 =>stack
  -스택을 이용해서 갈 수 있는 만큼 최대한 많이가고
  - 갈 수 없으면 이전 정점으로 돌아간다.
  - check[i]: 0 or 1 (0이면 방문x 1이면 방문) 배열
    :우리끼리 약속한가지 갈수있으면 수가 낮은 정점에 방문하자.
  ->인접행렬:시간복잡도는 O(V^2), 인접리스트:시간복잡도 O(E+V)
 
 2.너비우선 탐색 (중요) [Breadth First Search]
  ->최대한 넓게 가는것 =>queue
  - 모든 가중치가 1인경우 최단거리를 찾게됨
  - 큐를 이용해서 지금위치에서 갈 수 있는 접점을 모두 큐에넣는방식
  - dfs와 똑같이 check[i] 배열 필요
  - BFS와 DFS의 가장큰 차이는 다음 간선을 어떻게 방문할지 로직이다르다.
  ->인접행렬:V^2, 인접이르스트 O(V+E)

-------------------------------------------
bfs,dfs 1260
